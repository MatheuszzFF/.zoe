---
description:
globs:
alwaysApply: false
---
# Hooks Frontend

## Princípios Fundamentais

### 1. Hooks Personalizados
```typescript
// Exemplo de hook personalizado
import { useState, useEffect } from 'react'

function useWindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  })
  
  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight
      })
    }
    
    window.addEventListener('resize', handleResize)
    
    return () => {
      window.removeEventListener('resize', handleResize)
    }
  }, [])
  
  return size
}

// Uso do hook
function ResponsiveComponent() {
  const { width, height } = useWindowSize()
  
  return (
    <div>
      <p>Largura: {width}px</p>
      <p>Altura: {height}px</p>
    </div>
  )
}
```

### 2. useCallback
```typescript
// Exemplo de useCallback
import { useCallback } from 'react'

function SearchComponent() {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState([])
  
  const handleSearch = useCallback(async () => {
    const data = await fetchResults(query)
    setResults(data)
  }, [query])
  
  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />
      <button onClick={handleSearch}>
        Buscar
      </button>
      <ResultsList results={results} />
    </div>
  )
}
```

### 3. useMemo
```typescript
// Exemplo de useMemo
import { useMemo } from 'react'

function ExpensiveComponent({ items }) {
  const sortedItems = useMemo(() => {
    return items.sort((a, b) => a.name.localeCompare(b.name))
  }, [items])
  
  const total = useMemo(() => {
    return items.reduce((sum, item) => sum + item.price, 0)
  }, [items])
  
  return (
    <div>
      <ul>
        {sortedItems.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
      <p>Total: {total}</p>
    </div>
  )
}
```

### 4. useRef
```typescript
// Exemplo de useRef
import { useRef, useEffect } from 'react'

function AutoFocusInput() {
  const inputRef = useRef<HTMLInputElement>(null)
  
  useEffect(() => {
    inputRef.current?.focus()
  }, [])
  
  return (
    <input
      ref={inputRef}
      type="text"
      placeholder="Auto focus"
    />
  )
}

// Exemplo de useRef para valores
function Counter() {
  const countRef = useRef(0)
  
  const increment = () => {
    countRef.current += 1
    console.log(countRef.current)
  }
  
  return (
    <button onClick={increment}>
      Increment
    </button>
  )
}
```

### 5. useReducer
```typescript
// Exemplo de useReducer
import { useReducer } from 'react'

type State = {
  count: number
  step: number
}

type Action =
  | { type: 'INCREMENT' }
  | { type: 'DECREMENT' }
  | { type: 'SET_STEP'; payload: number }

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + state.step }
    case 'DECREMENT':
      return { ...state, count: state.count - state.step }
    case 'SET_STEP':
      return { ...state, step: action.payload }
    default:
      return state
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, {
    count: 0,
    step: 1
  })
  
  return (
    <div>
      <input
        type="number"
        value={state.step}
        onChange={(e) => dispatch({
          type: 'SET_STEP',
          payload: Number(e.target.value)
        })}
      />
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>
        -
      </button>
      <span>{state.count}</span>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>
        +
      </button>
    </div>
  )
}
```

### 6. useContext
```typescript
// Exemplo de useContext
import { createContext, useContext } from 'react'

type Theme = 'light' | 'dark'

const ThemeContext = createContext<{
  theme: Theme
  toggleTheme: () => void
} | null>(null)

function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>('light')
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light')
  }
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}

function useTheme() {
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider')
  }
  return context
}

function ThemedButton() {
  const { theme, toggleTheme } = useTheme()
  
  return (
    <button
      onClick={toggleTheme}
      className={theme}
    >
      Toggle theme
    </button>
  )
}
```

### 7. useLayoutEffect
```typescript
// Exemplo de useLayoutEffect
import { useLayoutEffect, useRef } from 'react'

function MeasureComponent() {
  const ref = useRef<HTMLDivElement>(null)
  const [size, setSize] = useState({ width: 0, height: 0 })
  
  useLayoutEffect(() => {
    if (ref.current) {
      const { width, height } = ref.current.getBoundingClientRect()
      setSize({ width, height })
    }
  }, [])
  
  return (
    <div ref={ref}>
      <p>Width: {size.width}px</p>
      <p>Height: {size.height}px</p>
    </div>
  )
}
```

### 8. useId
```typescript
// Exemplo de useId
import { useId } from 'react'

function FormField() {
  const id = useId()
  
  return (
    <div>
      <label htmlFor={id}>Nome</label>
      <input id={id} type="text" />
    </div>
  )
}
```

### 9. useTransition
```typescript
// Exemplo de useTransition
import { useTransition } from 'react'

function SearchResults() {
  const [isPending, startTransition] = useTransition()
  const [results, setResults] = useState([])
  
  const handleSearch = (query: string) => {
    startTransition(() => {
      setResults(expensiveSearch(query))
    })
  }
  
  return (
    <div>
      {isPending ? (
        <Spinner />
      ) : (
        <ResultsList results={results} />
      )}
    </div>
  )
}
```

### 10. Boas Práticas
- Use hooks personalizados para lógica reutilizável
- Evite loops infinitos
- Limpe efeitos adequadamente
- Use TypeScript
- Documente hooks
- Teste hooks
- Mantenha hooks pequenos
- Evite dependências desnecessárias
- Use memoização quando apropriado
- Siga as regras dos hooks
