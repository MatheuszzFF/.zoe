---
description: 
globs: 
alwaysApply: false
---
# Componentes Frontend

## Princípios Fundamentais

### 1. Estrutura de Componentes
```typescript
// Exemplo de componente
interface ButtonProps {
  variant?: 'primary' | 'secondary'
  size?: 'sm' | 'md' | 'lg'
  children: React.ReactNode
  onClick?: () => void
  disabled?: boolean
}

export function Button({ 
  variant = 'primary',
  size = 'md',
  children,
  onClick,
  disabled
}: ButtonProps) {
  return (
    <button
      className={cn(
        'rounded-md font-medium transition-colors',
        variant === 'primary' && 'bg-primary text-white hover:bg-primary/90',
        variant === 'secondary' && 'bg-secondary text-gray-900 hover:bg-secondary/90',
        size === 'sm' && 'px-3 py-1.5 text-sm',
        size === 'md' && 'px-4 py-2',
        size === 'lg' && 'px-6 py-3 text-lg',
        disabled && 'opacity-50 cursor-not-allowed'
      )}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  )
}
```

### 2. Props
- Tipagem forte com TypeScript
- Props opcionais com valores padrão
- Documentação com JSDoc
- Validação de props
- Props de composição

### 3. Estado
```typescript
// Exemplo de estado local
function Counter() {
  const [count, setCount] = useState(0)
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>
        Increment
      </button>
    </div>
  )
}
```

### 4. Efeitos
```typescript
// Exemplo de useEffect
function DataFetcher({ id }: { id: string }) {
  const [data, setData] = useState<Data | null>(null)
  const [loading, setLoading] = useState(true)
  
  useEffect(() => {
    async function fetchData() {
      try {
        const result = await api.getData(id)
        setData(result)
      } catch (error) {
        console.error(error)
      } finally {
        setLoading(false)
      }
    }
    
    fetchData()
  }, [id])
  
  if (loading) return <Spinner />
  if (!data) return <Error />
  
  return <DataDisplay data={data} />
}
```

### 5. Composição
- Componentes pequenos e focados
- Composição sobre herança
- Props drilling evitado
- Componentes compostos
- Render props

### 6. Performance
```typescript
// Exemplo de memoização
const MemoizedComponent = memo(function Component({ data }: Props) {
  return <div>{data}</div>
})

// Exemplo de useMemo
const sortedItems = useMemo(() => {
  return items.sort((a, b) => a.name.localeCompare(b.name))
}, [items])

// Exemplo de useCallback
const handleClick = useCallback(() => {
  console.log('clicked')
}, [])
```

### 7. Acessibilidade
- Semântica HTML
- ARIA labels
- Keyboard navigation
- Focus management
- Screen reader support

### 8. Estilização
- CSS-in-JS ou CSS Modules
- Design tokens
- Responsividade
- Theming
- Animations

### 9. Testes
```typescript
// Exemplo de teste
describe('Button', () => {
  it('renders correctly', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByText('Click me')).toBeInTheDocument()
  })
  
  it('handles click', () => {
    const onClick = jest.fn()
    render(<Button onClick={onClick}>Click me</Button>)
    fireEvent.click(screen.getByText('Click me'))
    expect(onClick).toHaveBeenCalled()
  })
  
  it('can be disabled', () => {
    render(<Button disabled>Click me</Button>)
    expect(screen.getByText('Click me')).toBeDisabled()
  })
})
```

### 10. Documentação
- JSDoc comments
- Storybook stories
- Props table
- Usage examples
- Accessibility notes

# Regras de Componentes

## Estrutura de Arquivos
- Cada componente deve seguir a estrutura:
  ```
  [nome]/
  ├── [nome].component.tsx
  ├── [nome].template.tsx
  └── [nome].types.ts
  ```

## Reutilização e Abstração
- [ ] Antes de criar um novo componente, verificar se já existe algo similar no projeto
- [ ] Ao identificar código duplicado em diferentes locais:
  - [ ] Abstrair em um componente reutilizável
  - [ ] Documentar o componente com exemplos de uso
  - [ ] Atualizar todos os locais que usavam a implementação antiga
- [ ] Componentes reutilizáveis devem:
  - [ ] Ser genéricos o suficiente para diferentes casos de uso
  - [ ] Ter props bem definidas e tipadas
  - [ ] Incluir documentação clara
  - [ ] Ter testes unitários

## Nomenclatura
- [ ] Usar PascalCase para nomes de componentes
- [ ] Sufixos obrigatórios:
  - [ ] `.component.tsx` para lógica
  - [ ] `.template.tsx` para template
  - [ ] `.types.ts` para tipos

## Organização
- [ ] Componentes específicos de página: `src/app/(internal)/[pagina]/components/`
- [ ] Componentes compartilhados: `src/components/`
- [ ] Componentes UI: `src/components/ui/`

## Boas Práticas
- [ ] Manter componentes pequenos e focados
- [ ] Usar TypeScript para todos os componentes
- [ ] Documentar props e tipos
- [ ] Implementar testes unitários
- [ ] Seguir princípios SOLID

## Exemplos
```typescript
// [nome].types.ts
export interface ComponentProps {
  // props aqui
}

// [nome].component.tsx
import { ComponentProps } from './[nome].types'
import { ComponentTemplate } from './[nome].template'

export function Component({ ...props }: ComponentProps) {
  // lógica aqui
  return <ComponentTemplate {...props} />
}

// [nome].template.tsx
import { ComponentProps } from './[nome].types'

export function ComponentTemplate({ ...props }: ComponentProps) {
  // template aqui
}
```
