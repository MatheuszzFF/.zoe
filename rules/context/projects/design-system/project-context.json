{
  "_metadata": {
    "version": "2.0",
    "created": "2025-06-09",
    "last_updated": "2025-06-09",
    "project_name": "design-system",
    "project_type": "Design System Library",
    "description": "Sistema de design React com componentes reutilizáveis e padrões arquiteturais específicos"
  },
  "project_overview": {
    "name": "design-system",
    "type": "Design System Library",
    "objectives": [
      "Criar componentes React reutilizáveis",
      "Estabelecer padrões de design consistentes",
      "Fornecer documentação completa via Storybook"
    ],
    "current_phase": "Development",
    "priority_focus": "Component Architecture & Quality",
    "location": "mzpkg/packages/design-system",
    "mono_repo": true
  },
  "tech_stack": {
    "detected_automatically": true,
    "detection_confidence": "high",
    "detection_method": "file_analysis",
    "frontend": {
      "language": "TypeScript",
      "framework": "React",
      "meta_framework": "None",
      "css_framework": "styled-components",
      "styling": "styled-components with transient props",
      "documentation": "Storybook",
      "testing": "Jest + React Testing Library",
      "build": "Rollup/Webpack"
    },
    "backend": {
      "runtime": "N/A",
      "database": "N/A",
      "orm": "N/A"
    },
    "development": {
      "testing": "Jest + React Testing Library",
      "bundler": "Rollup/Webpack",
      "linting": "ESLint",
      "package_manager": "npm/yarn",
      "type_checking": "TypeScript"
    }
  },
  "architectural_patterns": {
    "component_architecture": {
      "separation_pattern": "Component-Template-Types separation",
      "file_structure": {
        "component_file": "*.component.tsx - Lógica e estado",
        "template_file": "*.template.tsx - Apresentação visual",
        "types_file": "*.types.ts - Definições de tipos",
        "stories_file": "*.stories.tsx - Documentação Storybook",
        "test_files": "*.spec.tsx - Testes unitários"
      },
      "responsibility_separation": {
        "logic_layer": "Component files handle state, effects, and business logic",
        "presentation_layer": "Template files handle visual rendering and styling",
        "type_layer": "Types files define interfaces, props, and type definitions"
      }
    },
    "export_patterns": {
      "individual_exports": "Each component exports its main component and types",
      "grouped_exports": "Category-based exports (e.g., Buttons object with all button variants)",
      "namespace_exports": "Composite objects for related components (e.g., TableComposite)"
    },
    "composition_patterns": {
      "composite_components": "Complex components organized as composite objects (TableComposite)",
      "sub_components": "Related components grouped in category folders",
      "compound_components": "Components that work together as a system"
    }
  },
  "code_patterns": {
    "typing_conventions": {
      "pattern": "T prefix for types (TButton, TTable)",
      "rules": [
        "Props types: T{ComponentName}Props",
        "Component types: T{ComponentName}",
        "Template types: T{ComponentName}Template",
        "Export types: T{ComponentName}Exports"
      ],
      "prefix_usage": "T prefix for all custom types",
      "interface_vs_type": "Prefer type aliases over interfaces"
    },
    "props_structure": {
      "pattern": "Destructured props with default values",
      "destructuring_style": "Object destructuring in function parameters",
      "rules": [
        "Use transient props ($prop) for styled-components",
        "Separate logic props from styling props",
        "Forward HTML attributes when appropriate"
      ]
    },
    "styling_patterns": {
      "transient_props": "Use $ prefix for styled-components props ($bgColor, $color)",
      "prop_forwarding": "Forward HTML attributes using ...rest pattern",
      "theme_usage": "Access theme through styled-components ThemeProvider",
      "responsive_patterns": "Use theme breakpoints for responsive design"
    },
    "component_patterns": {
      "state_management": "useState for local state, useEffect for side effects",
      "effect_usage": "useEffect for mounting state and cleanup",
      "ref_patterns": "forwardRef for template components",
      "async_handling": "Loading states with isLoading prop pattern"
    },
    "testing_patterns": {
      "test_structure": "Describe blocks for component behavior",
      "user_interaction_testing": "fireEvent for user interactions",
      "accessibility_testing": "screen.getByRole for accessibility testing",
      "coverage_requirements": "Test component logic and user interactions"
    },
    "documentation_patterns": {
      "storybook_structure": "Default export with component metadata",
      "story_naming": "Descriptive story names (Default, WithLoading, etc.)",
      "controls_usage": "argTypes for interactive controls",
      "documentation_requirements": "Each component needs Default story minimum"
    }
  },
  "component_organization": {
    "directory_structure": {
      "component_folders": "Category-based folders (buttons/, table/, etc.)",
      "sub_component_organization": "Individual component folders within categories",
      "shared_components": "Common components in shared directories"
    },
    "naming_conventions": {
      "file_naming": "kebab-case for files (button.component.tsx)",
      "component_naming": "PascalCase for components (Button, TableComposite)",
      "export_naming": "Named exports with consistent naming"
    },
    "categorization": {
      "component_categories": ["buttons", "table", "forms", "layout", "feedback"],
      "complexity_levels": ["atomic", "molecular", "organism"],
      "usage_patterns": ["standalone", "composite", "compound"]
    }
  },
  "quality_standards": {
    "testing": {
      "framework": "Jest + React Testing Library",
      "required_tests": ["component rendering", "user interactions", "prop variations"],
      "coverage_targets": "Focus on component logic and user flows",
      "testing_utilities": ["@testing-library/react", "@testing-library/jest-dom"]
    },
    "documentation": {
      "storybook_required": true,
      "story_descriptions": "Required for all public components",
      "playground_stories": "Interactive stories with controls",
      "documentation_completeness": "Default story + variations minimum"
    },
    "code_quality": {
      "linting": "ESLint with React and TypeScript rules",
      "type_checking": "Strict TypeScript configuration",
      "formatting": "Prettier for consistent formatting",
      "performance_considerations": ["React.memo for expensive components", "Proper prop drilling"]
    },
    "accessibility": {
      "a11y_requirements": ["ARIA labels", "keyboard navigation", "screen reader support"],
      "keyboard_navigation": "Tab order and keyboard interactions",
      "screen_reader_support": "Semantic HTML and ARIA attributes"
    }
  },
  "architectural_decisions": [
    {
      "date": "2025-06-09",
      "decision": "Component-Template-Types separation pattern",
      "rationale": "Clear separation of concerns between logic and presentation",
      "impact": "Improved maintainability and testability"
    },
    {
      "date": "2025-06-09", 
      "decision": "Composite pattern for complex components",
      "rationale": "Better organization of related components",
      "impact": "Easier component discovery and usage"
    },
    {
      "date": "2025-06-09",
      "decision": "T prefix for type naming",
      "rationale": "Consistent type identification across codebase",
      "impact": "Better developer experience and code clarity"
    }
  ],
  "components_created": [
    {
      "name": "Table",
      "category": "table",
      "status": "completed",
      "files": ["table.component.tsx", "table.template.tsx", "table.types.ts", "table.stories.tsx"],
      "complexity": "organism",
      "last_updated": "2025-06-09"
    },
    {
      "name": "Button",
      "category": "buttons", 
      "status": "completed",
      "files": ["button.component.tsx", "button.template.tsx", "button.types.ts", "button.stories.tsx"],
      "complexity": "atomic",
      "last_updated": "2025-06-09"
    }
  ],
  "component_inventory": {
    "by_category": {
      "buttons": {
        "components": ["Button", "CancelButton", "CloseButton", "ConfirmButton", "DeleteButton", "EditButton", "SaveButton", "SubmitButton"],
        "complexity": "atomic to molecular",
        "status": "completed"
      },
      "table": {
        "components": ["Table", "TableComposite"],
        "complexity": "organism",
        "status": "completed"
      }
    },
    "by_status": {
      "completed": ["Button", "Table", "CancelButton", "CloseButton", "ConfirmButton", "DeleteButton", "EditButton", "SaveButton", "SubmitButton"],
      "in_progress": [],
      "planned": []
    }
  },
  "development_workflow": {
    "component_creation_process": [
      "Create component folder structure",
      "Define types in *.types.ts",
      "Implement logic in *.component.tsx", 
      "Create template in *.template.tsx",
      "Write tests in *.spec.tsx",
      "Document in *.stories.tsx",
      "Export in index.ts"
    ],
    "testing_workflow": [
      "Write unit tests for component logic",
      "Test user interactions",
      "Verify accessibility",
      "Run test suite"
    ],
    "documentation_workflow": [
      "Create Default story",
      "Add interactive controls",
      "Document component variations",
      "Review Storybook output"
    ],
    "review_process": [
      "Code review for patterns compliance",
      "Test coverage verification", 
      "Documentation completeness check",
      "Accessibility audit"
    ]
  },
  "storybook_stories": {
    "naming_pattern": "Components/{ComponentName}",
    "title_format": "Components/{ComponentName}",
    "rules": [
      "NUNCA alterar títulos existentes sem solicitação explícita",
      "Manter consistência com padrão Components/",
      "Usar PascalCase para nomes de componentes",
      "Incluir controles interativos quando apropriado"
    ],
    "required_stories": ["Default"],
    "optional_stories": ["Variants", "Playground", "Examples"]
  },
  "preferences": {
    "math_preferences": {
      "communication_style": "Direct and practical",
      "nickname": "Math", 
      "language": "Portuguese",
      "feedback_style": "Honest and specific"
    },
    "coding_style": {
      "file_naming": "English",
      "comments": "Portuguese",
      "variables": "English preferred", 
      "documentation": "Portuguese"
    },
    "project_style": {
      "component_priority": "Quality over quantity",
      "test_coverage": "Focus on component logic and user interactions",
      "documentation": "Complete Storybook documentation required"
    }
  },
  "current_context": {
    "last_session_summary": "Analyzed component architecture and updated project context with detailed patterns",
    "active_work": "Component architecture documentation and pattern standardization",
    "next_suggested": [
      "Continue component development following established patterns",
      "Expand component library with new categories",
      "Improve testing coverage"
    ],
    "pending_tasks": [],
    "blockers": [],
    "recent_changes": [
      "Updated project context with detailed architectural patterns",
      "Documented component-template-types separation pattern",
      "Established typing conventions and export patterns"
    ],
    "next_priorities": [
      "Maintain consistency with established patterns",
      "Focus on component quality and documentation",
      "Expand component inventory systematically"
    ]
  },
  "learning_insights": [
    {
      "date": "2025-06-09",
      "insight": "Component-Template-Types separation provides clear responsibility boundaries",
      "impact": "Better code organization and maintainability",
      "application": "Apply to all new components"
    },
    {
      "date": "2025-06-09", 
      "insight": "Composite pattern works well for complex components with multiple sub-components",
      "impact": "Easier component discovery and usage",
      "application": "Use for complex components like Table, Form, etc."
    },
    {
      "date": "2025-06-09",
      "insight": "Consistent type naming with T prefix improves developer experience",
      "impact": "Better code clarity and IntelliSense",
      "application": "Apply T prefix to all custom types"
    },
    {
      "date": "2025-06-09",
      "insight": "Transient props ($prop) pattern keeps styled-components clean",
      "impact": "Prevents prop forwarding issues",
      "application": "Use $ prefix for all styling props"
    }
  ],
  "project_metrics": {
    "components_completed": 9,
    "tests_created": 8,
    "sessions_count": 3,
    "days_worked": 1,
    "creation_date": "2025-06-09",
    "last_activity": "2025-06-09"
  },
  "patterns": {
    "architectural": "./patterns/architectural-patterns.json",
    "code": "./patterns/code-patterns.json",
    "component": "./patterns/component-patterns.json",
    "testing": "./patterns/testing-patterns.json",
    "documentation": "./patterns/documentation-patterns.json"
  }
} 