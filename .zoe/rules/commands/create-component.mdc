---
description: 
globs: 
alwaysApply: false
---
# üß© Create Component

## Comando
`criar componente [nome]` ou `criar componente [nome] design system`

## Comportamento
**Criar estrutura completa de componente React:**

### **Estrutura criada (componente comum):**
```
components/[nome-do-componente]/
‚îú‚îÄ‚îÄ [nome].component.tsx    # Toda a l√≥gica (useState, useEffect, handlers)
‚îú‚îÄ‚îÄ [nome].template.tsx     # Toda a estrutura visual
‚îú‚îÄ‚îÄ [nome].classes.ts       # Classes Tailwind organizadas (se Tailwind)
‚îú‚îÄ‚îÄ [nome].types.ts         # Types TypeScript (T[NomeComponente] = {...})
‚îú‚îÄ‚îÄ [nome].test.tsx         # Testes com userEvent e testing-library
‚îî‚îÄ‚îÄ [nome].composite.tsx    # Subcomponentes reutiliz√°veis (opcional)
```

### **Estrutura criada (design system):**
```
components/[nome-do-componente]/
‚îú‚îÄ‚îÄ [nome].component.tsx    # Toda a l√≥gica (useState, useEffect, handlers)
‚îú‚îÄ‚îÄ [nome].template.tsx     # Toda a estrutura visual
‚îú‚îÄ‚îÄ [nome].classes.ts       # Classes Tailwind organizadas (se Tailwind)
‚îú‚îÄ‚îÄ [nome].types.ts         # Types TypeScript (T[NomeComponente] = {...})
‚îú‚îÄ‚îÄ [nome].test.tsx         # Testes com userEvent e testing-library
‚îú‚îÄ‚îÄ [nome].composite.tsx    # Subcomponentes reutiliz√°veis (opcional)
‚îî‚îÄ‚îÄ [nome].stories.tsx      # Stories do Storybook üìö
```

## Processo
1. **Detectar flag "design system"** no comando
2. **Detectar estilo** ‚Üí @./commands/detect-style.mdc
3. **Usar template** ‚Üí @./templates/react-component.mdc
4. **Criar arquivo .test.tsx** com template de testes OBRIGAT√ìRIO
5. **SE design system:** Criar arquivo .stories.tsx com template completo
6. **Criar estrutura** completa de arquivos
7. **Aplicar padr√µes** React/TypeScript
8. **Documentar cria√ß√£o** no progresso

## Conven√ß√£o de Tipagem
**SEMPRE usar `type` com padr√£o `T[NomeComponente]`:**
```typescript
// ‚úÖ Correto
export type TButton = {
  variant?: 'primary' | 'secondary'
  size?: 'sm' | 'md' | 'lg'
  onClick?: () => void
}

export type TButtonState = {
  isLoading: boolean
  isPressed: boolean
}

// ‚ùå Evitar interfaces
export interface ButtonProps { ... }
```

## Estrutura de Props
**SEMPRE receber props como objeto √∫nico e desestruturar internamente:**
```typescript
// ‚úÖ Correto - Componente principal
export const Button: React.FC<TButton> = (props) => {
  const { variant, size, onClick, children } = props
  // l√≥gica do componente
}

// ‚úÖ Correto - Template 
export const ButtonTemplate: React.FC<TButtonTemplate> = (props) => {
  const { variant, size, className, children } = props
  // estrutura visual
}

// ‚ùå Evitar desestrutura√ß√£o direta nos par√¢metros
export const Button: React.FC<TButton> = ({ variant, size, onClick }) => {}
```

## Testes Obrigat√≥rios
**SEMPRE criar arquivo .test.tsx com:**
```typescript
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { [Nome] } from './[nome].component'

describe('[Nome] Component', () => {
  // ‚úÖ Setup obrigat√≥rio
  const user = userEvent.setup()

  it('should render correctly', () => {
    render(<[Nome] onChange={vi.fn()} />)
    expect(screen.getByRole('button')).toBeInTheDocument()
  })

  it('should handle user interactions', async () => {
    const mockOnChange = vi.fn()
    render(<[Nome] onChange={mockOnChange} />)
    
    const button = screen.getByRole('button')
    await user.click(button)
    
    expect(mockOnChange).toHaveBeenCalled()
  })

  it('should handle keyboard navigation', async () => {
    render(<[Nome] onChange={vi.fn()} />)
    
    await user.tab()
    expect(screen.getByRole('button')).toHaveFocus()
    
    await user.keyboard('{Enter}')
    // verificar comportamento esperado
  })

  it('should handle different states', () => {
    // Testar estados: loading, error, disabled, etc.
    render(<[Nome] disabled onChange={vi.fn()} />)
    expect(screen.getByRole('button')).toBeDisabled()
  })
})
```

### Padr√µes de Teste:
- **userEvent OBRIGAT√ìRIO** ‚Üí `const user = userEvent.setup()`
- **Nunca fireEvent** ‚Üí Sempre userEvent para intera√ß√µes realistas
- **Testes essenciais:** Renderiza√ß√£o, Intera√ß√µes, Estados, Acessibilidade
- **Ferramentas:** Vitest + @testing-library/react + @testing-library/user-event

## Template Stories (Design System)
**Quando detectar "design system", criar arquivo .stories.tsx com:**
```typescript
import type { Meta, StoryObj } from '@storybook/react'
import { [Nome] } from './[nome].component'

const meta: Meta<typeof [Nome]> = {
  title: 'Design System/[Nome]',
  component: [Nome],
  parameters: {
    layout: 'centered',
  },
  tags: ['autodocs'],
  argTypes: {
    // Definir controles baseados nas props do componente
  },
}

export default meta
type Story = StoryObj<typeof meta>

// Story padr√£o
export const Default: Story = {
  args: {
    // Props padr√£o do componente
  },
}

// Varia√ß√µes baseadas no tipo do componente
export const Variants: Story = {
  render: () => (
    <div className="flex gap-4">
      {/* Diferentes varia√ß√µes do componente */}
    </div>
  ),
}
```

## Separa√ß√£o de Responsabilidades
- **.component.tsx** ‚Üí L√≥gica e state
- **.template.tsx** ‚Üí Estrutura visual
- **.classes.ts** ‚Üí Estilos (se Tailwind)
- **.types.ts** ‚Üí Types (padr√£o T[NomeComponente])
- **.test.tsx** ‚Üí Testes com userEvent (OBRIGAT√ìRIO)
- **.composite.tsx** ‚Üí Subcomponentes (opcional)
- **.stories.tsx** ‚Üí Documenta√ß√£o interativa (design system)

## Objetivo
Criar componentes com estrutura padronizada, tipagem consistente e stories autom√°ticos para design system

